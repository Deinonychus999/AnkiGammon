"""Generate Anki card content from XG decisions."""

import random
import string
from pathlib import Path
from typing import List, Dict, Optional, Tuple
from PIL import Image

from xg2anki.models import Decision, Move, Player
from xg2anki.renderer.board_renderer import BoardRenderer
from xg2anki.utils.move_parser import MoveParser


class CardGenerator:
    """
    Generates Anki card content from XG decisions.

    Supports two variants:
    1. Simple: Shows question only (no options)
    2. Text MCQ: Shows move notation as text options
    """

    def __init__(
        self,
        output_dir: Path,
        show_options: bool = False,
        interactive_moves: bool = False,
        renderer: Optional[BoardRenderer] = None
    ):
        """
        Initialize the card generator.

        Args:
            output_dir: Directory to save generated images
            show_options: If True, show multiple choice options (text only)
            interactive_moves: If True, render positions for all moves (clickable analysis)
            renderer: Board renderer instance (creates default if None)
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

        self.show_options = show_options
        self.interactive_moves = interactive_moves
        self.renderer = renderer or BoardRenderer()

        # Create media directory
        self.media_dir = self.output_dir / "media"
        self.media_dir.mkdir(exist_ok=True)

    def generate_card(self, decision: Decision, card_id: Optional[str] = None) -> Dict[str, any]:
        """
        Generate an Anki card from a decision.

        Args:
            decision: The decision to create a card for
            card_id: Optional card ID (generated if not provided)

        Returns:
            Dictionary with card data:
            {
                'front': HTML for card front,
                'back': HTML for card back,
                'media_files': List of media file paths,
                'tags': List of tags
            }
        """
        if card_id is None:
            card_id = self._generate_id()

        # Generate position image (before move)
        position_image = self._get_or_render_position_image(decision, card_id)

        # Prepare candidate moves
        # For cube decisions: use all 5 options (already generated by parser)
        # For checker play: use top 5 moves, don't pad if fewer
        from xg2anki.models import DecisionType

        if decision.decision_type == DecisionType.CUBE_ACTION:
            # Cube decisions should have exactly 5 options
            candidates = decision.candidate_moves[:5]
        else:
            # Checker play: take top 5, don't pad
            candidates = decision.candidate_moves[:5]

        # Shuffle candidates for MCQ
        shuffled_candidates, answer_index = self._shuffle_candidates(candidates)

        # Generate card front
        if self.show_options:
            front_html = self._generate_text_mcq_front(
                decision, position_image, shuffled_candidates
            )
        else:
            front_html = self._generate_simple_front(
                decision, position_image
            )

        # Generate resulting position images
        move_result_images = {}
        best_move = decision.get_best_move()

        if self.interactive_moves:
            # Render all candidate move positions for interactive visualization
            for i, candidate in enumerate(candidates):
                if candidate:
                    result_img = self._render_resulting_position(
                        decision, candidate, f"{card_id}_move_{i}"
                    )
                    move_result_images[candidate.notation] = result_img
            result_image = move_result_images.get(best_move.notation) if best_move else None
        else:
            # Only render the best move's resulting position
            if best_move:
                result_image = self._render_resulting_position(
                    decision, best_move, f"{card_id}_result"
                )
                move_result_images[best_move.notation] = result_image
            else:
                result_image = None

        # Generate card back
        back_html = self._generate_back(
            decision, position_image, result_image, candidates, answer_index,
            self.show_options, move_result_images
        )

        # Collect media files
        media_files = [position_image] + list(move_result_images.values())

        # Generate tags
        tags = self._generate_tags(decision)

        return {
            'front': front_html,
            'back': back_html,
            'media_files': media_files,
            'tags': tags,
        }

    def _get_metadata_html(self, decision: Decision) -> str:
        """
        Get metadata HTML with colored player indicator.

        Returns HTML with inline colored circle representing the checker color.
        """
        # Get base metadata text (includes "White" or "Black")
        base_metadata = decision.get_metadata_text()

        # Get actual checker color from the renderer's color scheme
        if decision.on_roll == Player.X:
            checker_color = self.renderer.color_scheme.checker_x
        else:
            checker_color = self.renderer.color_scheme.checker_o

        # Replace "White" or "Black" with colored circle
        # Use HTML entity for circle (●) with inline style
        colored_circle = f'<span style="color: {checker_color}; font-size: 1.8em;">●</span>'

        # Replace the player name with the colored circle
        if decision.on_roll == Player.X:
            metadata_html = base_metadata.replace("White", colored_circle)
        else:
            metadata_html = base_metadata.replace("Black", colored_circle)

        return metadata_html

    def _generate_simple_front(
        self,
        decision: Decision,
        position_image: str
    ) -> str:
        """Generate HTML for simple front (no options)."""
        metadata = self._get_metadata_html(decision)

        html = f"""
<div class="card-front">
    <div class="position-image">
        <img src="{Path(position_image).name}" alt="Position" />
    </div>
    <div class="metadata">{metadata}</div>
    <div class="question">
        <h3>What is the best move?</h3>
    </div>
</div>
"""
        return html

    def _generate_text_mcq_front(
        self,
        decision: Decision,
        position_image: str,
        candidates: List[Optional[Move]]
    ) -> str:
        """Generate HTML for text-based MCQ front."""
        metadata = self._get_metadata_html(decision)

        # Format candidate options
        options_html = []
        letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']  # Support up to 10 options
        for i, candidate in enumerate(candidates):
            if candidate:
                options_html.append(
                    f"<div class='option'><strong>{letters[i]}.</strong> {candidate.notation}</div>"
                )

        html = f"""
<div class="card-front">
    <div class="position-image">
        <img src="{Path(position_image).name}" alt="Position" />
    </div>
    <div class="metadata">{metadata}</div>
    <div class="question">
        <h3>What is the best move?</h3>
        <div class="options">
            {''.join(options_html)}
        </div>
    </div>
</div>
"""
        return html

    def _generate_back(
        self,
        decision: Decision,
        original_position_image: str,
        result_position_image: str,
        candidates: List[Optional[Move]],
        answer_index: int,
        show_options: bool,
        move_result_images: Dict[str, str]
    ) -> str:
        """Generate HTML for card back."""
        metadata = self._get_metadata_html(decision)

        # Build move table - only show moves from XG's analysis
        table_rows = []
        letters = ['A', 'B', 'C', 'D', 'E']

        # Sort candidates by xg_rank for display in analysis table
        # (candidates are shuffled for MCQ, but analysis table should show XG's order)
        sorted_candidates = sorted(
            [m for m in candidates if m and m.from_xg_analysis],
            key=lambda m: m.xg_rank if m.xg_rank is not None else 999
        )

        for i, move in enumerate(sorted_candidates):
            # Use xg_rank for order (preserves XG's Cubeful Equities order)
            # Use xg_error for display (XG's error values, not our calculated ones)
            # Use xg_notation for display (e.g., "No double" not "No double/Take")
            # Highlight if this is the overall best move (rank == 1)
            rank_class = "best-move" if move.rank == 1 else ""
            display_rank = move.xg_rank if move.xg_rank is not None else (i + 1)
            display_error = move.xg_error if move.xg_error is not None else move.error
            display_notation = move.xg_notation if move.xg_notation is not None else move.notation

            # Format error with explicit + sign (matching XG's format)
            error_str = f"{display_error:+.3f}" if display_error != 0 else "0.000"

            # Add interactive attributes if enabled
            if self.interactive_moves:
                result_img = move_result_images.get(move.notation, "")
                result_img_name = Path(result_img).name if result_img else ""
                row_class = f"{rank_class} move-row"
                row_attrs = f'data-move-notation="{move.notation}" data-result-image="{result_img_name}"'
            else:
                row_class = rank_class
                row_attrs = ""

            table_rows.append(f"""
<tr class="{row_class}" {row_attrs}>
    <td>{display_rank}</td>
    <td>{display_notation}</td>
    <td>{move.equity:.3f}</td>
    <td>{error_str}</td>
</tr>
""")

        # Generate answer section
        best_move = decision.get_best_move()
        best_notation = best_move.notation if best_move else "Unknown"

        if show_options:
            # Show letter-based answer for MCQ
            correct_letter = letters[answer_index] if answer_index < len(letters) else "?"
            answer_html = f"""
    <div class="answer">
        <h3>Correct Answer: <span class="answer-letter">{correct_letter}</span></h3>
        <p class="best-move-notation">{best_notation}</p>
    </div>
"""
        else:
            # Show simple answer for non-MCQ
            answer_html = f"""
    <div class="answer">
        <h3>Best Move:</h3>
        <p class="best-move-notation">{best_notation}</p>
    </div>
"""

        # Prepare image paths for JavaScript
        original_img_name = Path(original_position_image).name
        result_img_name = Path(result_position_image).name if result_position_image else original_img_name

        # Generate position viewer HTML based on interactive_moves setting
        if self.interactive_moves:
            position_viewer_html = f"""
    <div class="position-viewer">
        <div class="position-image">
            <img id="position-display" src="{result_img_name}" alt="Position" data-original="{original_img_name}" data-current="{result_img_name}" />
        </div>
        <div class="position-label">
            <span id="position-status">After best move</span>
            <button id="toggle-position" class="toggle-btn">Show original position</button>
        </div>
    </div>"""
            analysis_title = '<h4>Top Moves Analysis: <span class="click-hint">(click a move to see the resulting position)</span></h4>'
            table_body_id = 'id="moves-tbody"'
        else:
            # Non-interactive mode: just show the resulting position
            position_viewer_html = f"""
    <div class="position-image">
        <img src="{result_img_name}" alt="Position" />
    </div>"""
            analysis_title = '<h4>Top Moves Analysis:</h4>'
            table_body_id = ''

        html = f"""
<div class="card-back">
{position_viewer_html}
    <div class="metadata">{metadata}</div>
{answer_html}
    <div class="analysis">
        {analysis_title}
        <table class="moves-table">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Move</th>
                    <th>Equity</th>
                    <th>Error</th>
                </tr>
            </thead>
            <tbody {table_body_id}>
                {''.join(table_rows)}
            </tbody>
        </table>
    </div>
    {self._generate_source_info(decision)}
</div>
"""

        # Add JavaScript for interactive mode
        if self.interactive_moves:
            html += """
<script>
(function() {
    // Get elements
    const positionImg = document.getElementById('position-display');
    const statusLabel = document.getElementById('position-status');
    const toggleBtn = document.getElementById('toggle-position');
    const moveRows = document.querySelectorAll('.move-row');

    // Track state
    let showingOriginal = false;
    const originalImg = positionImg.dataset.original;
    const bestMoveImg = positionImg.dataset.current;
    let currentSelectedRow = null;

    // Initialize - highlight best move row
    const bestMoveRow = document.querySelector('.move-row.best-move');
    if (bestMoveRow) {
        bestMoveRow.classList.add('selected');
        currentSelectedRow = bestMoveRow;
    }

    // Toggle button handler
    toggleBtn.addEventListener('click', function() {
        showingOriginal = !showingOriginal;

        if (showingOriginal) {
            positionImg.src = originalImg;
            statusLabel.textContent = 'Original position';
            toggleBtn.textContent = 'Show resulting position';

            // Deselect all rows
            moveRows.forEach(row => row.classList.remove('selected'));
            currentSelectedRow = null;
        } else {
            positionImg.src = bestMoveImg;
            statusLabel.textContent = 'After best move';
            toggleBtn.textContent = 'Show original position';

            // Re-select best move row
            if (bestMoveRow) {
                bestMoveRow.classList.add('selected');
                currentSelectedRow = bestMoveRow;
            }
        }
    });

    // Click handler for move rows
    moveRows.forEach(row => {
        row.addEventListener('click', function() {
            const resultImage = this.dataset.resultImage;
            const moveNotation = this.dataset.moveNotation;

            if (!resultImage) return;

            // If clicking the same row, toggle to original
            if (currentSelectedRow === this && !showingOriginal) {
                showingOriginal = true;
                positionImg.src = originalImg;
                statusLabel.textContent = 'Original position';
                toggleBtn.textContent = 'Show resulting position';
                this.classList.remove('selected');
                currentSelectedRow = null;
                return;
            }

            // Show this move's resulting position
            showingOriginal = false;
            positionImg.src = resultImage;
            statusLabel.textContent = 'After: ' + moveNotation;
            toggleBtn.textContent = 'Show original position';

            // Update selection
            moveRows.forEach(r => r.classList.remove('selected'));
            this.classList.add('selected');
            currentSelectedRow = this;
        });
    });
})();
</script>
"""

        return html

    def _generate_source_info(self, decision: Decision) -> str:
        """Generate source information HTML."""
        parts = []
        if decision.xgid:
            parts.append(f"<code>{decision.xgid}</code>")
        if decision.source_file:
            parts.append(f"Source: {decision.source_file}")
        if decision.game_number:
            parts.append(f"Game #{decision.game_number}")
        if decision.move_number:
            parts.append(f"Move #{decision.move_number}")

        if parts:
            return f"""
<div class="source-info">
    <p>{'<br>'.join(parts)}</p>
</div>
"""
        return ""

    def _generate_tags(self, decision: Decision) -> List[str]:
        """Generate tags for the card."""
        tags = ["xg2anki", "backgammon"]

        # Add decision type tag
        tags.append(decision.decision_type.value)

        # Add match/money tag
        if decision.match_length > 0:
            tags.append(f"match_{decision.match_length}pt")
        else:
            tags.append("money_game")

        # Add cube value tag
        if decision.cube_value > 1:
            tags.append(f"cube_{decision.cube_value}")

        return tags

    def _get_or_render_position_image(self, decision: Decision, card_id: str) -> str:
        """Get existing position image or render a new one."""
        import time
        import random

        # Use timestamp AND random suffix in filename to bust Anki's media cache
        # Anki aggressively caches media, so we need truly unique names
        timestamp = int(time.time() * 1000)  # milliseconds for more uniqueness
        random_suffix = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz0123456789', k=8))
        name_base = f"{card_id}_{timestamp}_{random_suffix}"

        # If decision has an existing image path, use it
        if decision.position_image_path and Path(decision.position_image_path).exists():
            # Copy to media directory
            src_path = Path(decision.position_image_path)
            dst_path = self.media_dir / f"{name_base}_position.png"

            # Always copy to ensure fresh file with new timestamp name
            Image.open(src_path).save(dst_path)

            return str(dst_path)

        # Otherwise, render the position
        img_path = self.media_dir / f"{name_base}_position.png"
        self.renderer.render(
            position=decision.position,
            on_roll=decision.on_roll,
            dice=decision.dice,
            cube_value=decision.cube_value,
            cube_owner=decision.cube_owner,
            output_path=str(img_path)
        )
        return str(img_path)

    def _render_resulting_position(
        self,
        decision: Decision,
        move: Move,
        img_id: str
    ) -> str:
        """Render the resulting position after a move."""
        import time
        import random

        # Add timestamp AND random suffix to bust Anki's cache
        # Anki aggressively caches media, so we need truly unique names
        timestamp = int(time.time() * 1000)
        random_suffix = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz0123456789', k=8))
        img_path = self.media_dir / f"{img_id}_{timestamp}_{random_suffix}.png"

        # If move already has resulting position, use it
        if move.resulting_position:
            resulting_pos = move.resulting_position
        else:
            # Apply move to position
            resulting_pos = MoveParser.apply_move(
                decision.position,
                move.notation,
                decision.on_roll
            )

        # Render the resulting position from the SAME perspective (same player at bottom)
        # Show dice with transparency to indicate the move has been made
        self.renderer.render(
            position=resulting_pos,
            on_roll=decision.on_roll,  # Keep same player at bottom (not opponent)
            dice=decision.dice,  # Show the same dice
            dice_opacity=0.3,  # Make dice semi-transparent to show move is complete
            cube_value=decision.cube_value,
            cube_owner=decision.cube_owner,
            output_path=str(img_path)
        )

        return str(img_path)

    def _shuffle_candidates(
        self,
        candidates: List[Optional[Move]]
    ) -> Tuple[List[Optional[Move]], int]:
        """
        Shuffle candidates for MCQ and return answer index.

        Returns:
            (shuffled_candidates, answer_index_of_best_move)
        """
        # Find best move (rank 1)
        best_idx = 0
        for i, candidate in enumerate(candidates):
            if candidate and candidate.rank == 1:
                best_idx = i
                break

        # Create shuffled list
        indices = list(range(len(candidates)))
        random.shuffle(indices)

        shuffled = [candidates[i] for i in indices]

        # Find new position of best move
        answer_idx = indices.index(best_idx)

        return shuffled, answer_idx

    def _generate_id(self) -> str:
        """Generate a random ID for a card."""
        return ''.join(random.choices(string.ascii_lowercase + string.digits, k=12))
